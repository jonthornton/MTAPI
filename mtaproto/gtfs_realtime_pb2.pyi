"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Protocol definition file for GTFS Realtime.

GTFS Realtime lets transit agencies provide consumers with realtime
information about disruptions to their service (stations closed, lines not
operating, important delays etc), location of their vehicles and expected
arrival times.

This protocol is published at:
https://github.com/google/transit/tree/master/gtfs-realtime
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class FeedMessage(google.protobuf.message.Message):
    """The contents of a feed message.
    A feed is a continuous stream of feed messages. Each message in the stream is
    obtained as a response to an appropriate HTTP GET request.
    A realtime feed is always defined with relation to an existing GTFS feed.
    All the entity ids are resolved with respect to the GTFS feed.
    Note that "required" and "optional" as stated in this file refer to Protocol
    Buffer cardinality, not semantic cardinality.  See reference.md at
    https://github.com/google/transit/tree/master/gtfs-realtime for field
    semantic cardinality.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HEADER_FIELD_NUMBER: builtins.int
    ENTITY_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> global___FeedHeader:
        """Metadata about this feed and feed message."""
    @property
    def entity(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FeedEntity]:
        """Contents of the feed."""
    def __init__(
        self,
        *,
        header: global___FeedHeader | None = ...,
        entity: collections.abc.Iterable[global___FeedEntity] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header", b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["entity", b"entity", "header", b"header"]) -> None: ...

global___FeedMessage = FeedMessage

@typing_extensions.final
class FeedHeader(google.protobuf.message.Message):
    """Metadata about a feed, included in feed messages."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Incrementality:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _IncrementalityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[FeedHeader._Incrementality.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        FULL_DATASET: FeedHeader._Incrementality.ValueType  # 0
        DIFFERENTIAL: FeedHeader._Incrementality.ValueType  # 1

    class Incrementality(_Incrementality, metaclass=_IncrementalityEnumTypeWrapper):
        """Determines whether the current fetch is incremental.  Currently,
        DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
        that use this mode.  There are discussions on the GTFS Realtime mailing
        list around fully specifying the behavior of DIFFERENTIAL mode and the
        documentation will be updated when those discussions are finalized.
        """

    FULL_DATASET: FeedHeader.Incrementality.ValueType  # 0
    DIFFERENTIAL: FeedHeader.Incrementality.ValueType  # 1

    GTFS_REALTIME_VERSION_FIELD_NUMBER: builtins.int
    INCREMENTALITY_FIELD_NUMBER: builtins.int
    TIMESTAMP_FIELD_NUMBER: builtins.int
    gtfs_realtime_version: builtins.str
    """Version of the feed specification.
    The current version is 2.0.
    """
    incrementality: global___FeedHeader.Incrementality.ValueType
    timestamp: builtins.int
    """This timestamp identifies the moment when the content of this feed has been
    created (in server time). In POSIX time (i.e., number of seconds since
    January 1st 1970 00:00:00 UTC).
    """
    def __init__(
        self,
        *,
        gtfs_realtime_version: builtins.str | None = ...,
        incrementality: global___FeedHeader.Incrementality.ValueType | None = ...,
        timestamp: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["gtfs_realtime_version", b"gtfs_realtime_version", "incrementality", b"incrementality", "timestamp", b"timestamp"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["gtfs_realtime_version", b"gtfs_realtime_version", "incrementality", b"incrementality", "timestamp", b"timestamp"]) -> None: ...

global___FeedHeader = FeedHeader

@typing_extensions.final
class FeedEntity(google.protobuf.message.Message):
    """A definition (or update) of an entity in the transit feed."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    IS_DELETED_FIELD_NUMBER: builtins.int
    TRIP_UPDATE_FIELD_NUMBER: builtins.int
    VEHICLE_FIELD_NUMBER: builtins.int
    ALERT_FIELD_NUMBER: builtins.int
    id: builtins.str
    """The ids are used only to provide incrementality support. The id should be
    unique within a FeedMessage. Consequent FeedMessages may contain
    FeedEntities with the same id. In case of a DIFFERENTIAL update the new
    FeedEntity with some id will replace the old FeedEntity with the same id
    (or delete it - see is_deleted below).
    The actual GTFS entities (e.g. stations, routes, trips) referenced by the
    feed must be specified by explicit selectors (see EntitySelector below for
    more info).
    """
    is_deleted: builtins.bool
    """Whether this entity is to be deleted. Relevant only for incremental
    fetches.
    """
    @property
    def trip_update(self) -> global___TripUpdate:
        """Data about the entity itself. Exactly one of the following fields must be
        present (unless the entity is being deleted).
        """
    @property
    def vehicle(self) -> global___VehiclePosition: ...
    @property
    def alert(self) -> global___Alert: ...
    def __init__(
        self,
        *,
        id: builtins.str | None = ...,
        is_deleted: builtins.bool | None = ...,
        trip_update: global___TripUpdate | None = ...,
        vehicle: global___VehiclePosition | None = ...,
        alert: global___Alert | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["alert", b"alert", "id", b"id", "is_deleted", b"is_deleted", "trip_update", b"trip_update", "vehicle", b"vehicle"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["alert", b"alert", "id", b"id", "is_deleted", b"is_deleted", "trip_update", b"trip_update", "vehicle", b"vehicle"]) -> None: ...

global___FeedEntity = FeedEntity

@typing_extensions.final
class TripUpdate(google.protobuf.message.Message):
    """
    Entities used in the feed.

    Realtime update of the progress of a vehicle along a trip.
    Depending on the value of ScheduleRelationship, a TripUpdate can specify:
    - A trip that proceeds along the schedule.
    - A trip that proceeds along a route but has no fixed schedule.
    - A trip that have been added or removed with regard to schedule.

    The updates can be for future, predicted arrival/departure events, or for
    past events that already occurred.
    Normally, updates should get more precise and more certain (see
    uncertainty below) as the events gets closer to current time.
    Even if that is not possible, the information for past events should be
    precise and certain. In particular, if an update points to time in the past
    but its update's uncertainty is not 0, the client should conclude that the
    update is a (wrong) prediction and that the trip has not completed yet.

    Note that the update can describe a trip that is already completed.
    To this end, it is enough to provide an update for the last stop of the trip.
    If the time of that is in the past, the client will conclude from that that
    the whole trip is in the past (it is possible, although inconsequential, to
    also provide updates for preceding stops).
    This option is most relevant for a trip that has completed ahead of schedule,
    but according to the schedule, the trip is still proceeding at the current
    time. Removing the updates for this trip could make the client assume
    that the trip is still proceeding.
    Note that the feed provider is allowed, but not required, to purge past
    updates - this is one case where this would be practically useful.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class StopTimeEvent(google.protobuf.message.Message):
        """Timing information for a single predicted event (either arrival or
        departure).
        Timing consists of delay and/or estimated time, and uncertainty.
        - delay should be used when the prediction is given relative to some
          existing schedule in GTFS.
        - time should be given whether there is a predicted schedule or not. If
          both time and delay are specified, time will take precedence
          (although normally, time, if given for a scheduled trip, should be
          equal to scheduled time in GTFS + delay).

        Uncertainty applies equally to both time and delay.
        The uncertainty roughly specifies the expected error in true delay (but
        note, we don't yet define its precise statistical meaning). It's possible
        for the uncertainty to be 0, for example for trains that are driven under
        computer timing control.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        DELAY_FIELD_NUMBER: builtins.int
        TIME_FIELD_NUMBER: builtins.int
        UNCERTAINTY_FIELD_NUMBER: builtins.int
        delay: builtins.int
        """Delay (in seconds) can be positive (meaning that the vehicle is late) or
        negative (meaning that the vehicle is ahead of schedule). Delay of 0
        means that the vehicle is exactly on time.
        """
        time: builtins.int
        """Event as absolute time.
        In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
        UTC).
        """
        uncertainty: builtins.int
        """If uncertainty is omitted, it is interpreted as unknown.
        If the prediction is unknown or too uncertain, the delay (or time) field
        should be empty. In such case, the uncertainty field is ignored.
        To specify a completely certain prediction, set its uncertainty to 0.
        """
        def __init__(
            self,
            *,
            delay: builtins.int | None = ...,
            time: builtins.int | None = ...,
            uncertainty: builtins.int | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["delay", b"delay", "time", b"time", "uncertainty", b"uncertainty"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["delay", b"delay", "time", b"time", "uncertainty", b"uncertainty"]) -> None: ...

    @typing_extensions.final
    class StopTimeUpdate(google.protobuf.message.Message):
        """Realtime update for arrival and/or departure events for a given stop on a
        trip. Updates can be supplied for both past and future events.
        The producer is allowed, although not required, to drop past events.
        The update is linked to a specific stop either through stop_sequence or
        stop_id, so one of the fields below must necessarily be set.
        See the documentation in TripDescriptor for more information.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _ScheduleRelationship:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _ScheduleRelationshipEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType], builtins.type):  # noqa: F821
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            SCHEDULED: TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType  # 0
            """The vehicle is proceeding in accordance with its static schedule of
            stops, although not necessarily according to the times of the schedule.
            At least one of arrival and departure must be provided. If the schedule
            for this stop contains both arrival and departure times then so must
            this update.
            """
            SKIPPED: TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType  # 1
            """The stop is skipped, i.e., the vehicle will not stop at this stop.
            Arrival and departure are optional.
            """
            NO_DATA: TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType  # 2
            """No data is given for this stop. The main intention for this value is to
            give the predictions only for part of a trip, i.e., if the last update
            for a trip has a NO_DATA specifier, then StopTimes for the rest of the
            stops in the trip are considered to be unspecified as well.
            Neither arrival nor departure should be supplied.
            """

        class ScheduleRelationship(_ScheduleRelationship, metaclass=_ScheduleRelationshipEnumTypeWrapper):
            """The relation between this StopTime and the static schedule."""

        SCHEDULED: TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType  # 0
        """The vehicle is proceeding in accordance with its static schedule of
        stops, although not necessarily according to the times of the schedule.
        At least one of arrival and departure must be provided. If the schedule
        for this stop contains both arrival and departure times then so must
        this update.
        """
        SKIPPED: TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType  # 1
        """The stop is skipped, i.e., the vehicle will not stop at this stop.
        Arrival and departure are optional.
        """
        NO_DATA: TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType  # 2
        """No data is given for this stop. The main intention for this value is to
        give the predictions only for part of a trip, i.e., if the last update
        for a trip has a NO_DATA specifier, then StopTimes for the rest of the
        stops in the trip are considered to be unspecified as well.
        Neither arrival nor departure should be supplied.
        """

        STOP_SEQUENCE_FIELD_NUMBER: builtins.int
        STOP_ID_FIELD_NUMBER: builtins.int
        ARRIVAL_FIELD_NUMBER: builtins.int
        DEPARTURE_FIELD_NUMBER: builtins.int
        SCHEDULE_RELATIONSHIP_FIELD_NUMBER: builtins.int
        stop_sequence: builtins.int
        """Must be the same as in stop_times.txt in the corresponding GTFS feed."""
        stop_id: builtins.str
        """Must be the same as in stops.txt in the corresponding GTFS feed."""
        @property
        def arrival(self) -> global___TripUpdate.StopTimeEvent: ...
        @property
        def departure(self) -> global___TripUpdate.StopTimeEvent: ...
        schedule_relationship: global___TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType
        def __init__(
            self,
            *,
            stop_sequence: builtins.int | None = ...,
            stop_id: builtins.str | None = ...,
            arrival: global___TripUpdate.StopTimeEvent | None = ...,
            departure: global___TripUpdate.StopTimeEvent | None = ...,
            schedule_relationship: global___TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["arrival", b"arrival", "departure", b"departure", "schedule_relationship", b"schedule_relationship", "stop_id", b"stop_id", "stop_sequence", b"stop_sequence"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["arrival", b"arrival", "departure", b"departure", "schedule_relationship", b"schedule_relationship", "stop_id", b"stop_id", "stop_sequence", b"stop_sequence"]) -> None: ...

    TRIP_FIELD_NUMBER: builtins.int
    VEHICLE_FIELD_NUMBER: builtins.int
    STOP_TIME_UPDATE_FIELD_NUMBER: builtins.int
    TIMESTAMP_FIELD_NUMBER: builtins.int
    DELAY_FIELD_NUMBER: builtins.int
    @property
    def trip(self) -> global___TripDescriptor:
        """The Trip that this message applies to. There can be at most one
        TripUpdate entity for each actual trip instance.
        If there is none, that means there is no prediction information available.
        It does *not* mean that the trip is progressing according to schedule.
        """
    @property
    def vehicle(self) -> global___VehicleDescriptor:
        """Additional information on the vehicle that is serving this trip."""
    @property
    def stop_time_update(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TripUpdate.StopTimeUpdate]:
        """Updates to StopTimes for the trip (both future, i.e., predictions, and in
        some cases, past ones, i.e., those that already happened).
        The updates must be sorted by stop_sequence, and apply for all the
        following stops of the trip up to the next specified one.

        Example 1:
        For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
        delay of 0 for stop_sequence of the current stop means that the trip is
        exactly on time.

        Example 2:
        For the same trip instance, 3 StopTimeUpdates are provided:
        - delay of 5 min for stop_sequence 3
        - delay of 1 min for stop_sequence 8
        - delay of unspecified duration for stop_sequence 10
        This will be interpreted as:
        - stop_sequences 3,4,5,6,7 have delay of 5 min.
        - stop_sequences 8,9 have delay of 1 min.
        - stop_sequences 10,... have unknown delay.
        """
    timestamp: builtins.int
    """Moment at which the vehicle's real-time progress was measured. In POSIX
    time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
    """
    delay: builtins.int
    """The current schedule deviation for the trip.  Delay should only be
    specified when the prediction is given relative to some existing schedule
    in GTFS.

    Delay (in seconds) can be positive (meaning that the vehicle is late) or
    negative (meaning that the vehicle is ahead of schedule). Delay of 0
    means that the vehicle is exactly on time.

    Delay information in StopTimeUpdates take precedent of trip-level delay
    information, such that trip-level delay is only propagated until the next
    stop along the trip with a StopTimeUpdate delay value specified.

    Feed providers are strongly encouraged to provide a TripUpdate.timestamp
    value indicating when the delay value was last updated, in order to
    evaluate the freshness of the data.

    NOTE: This field is still experimental, and subject to change. It may be
    formally adopted in the future.
    """
    def __init__(
        self,
        *,
        trip: global___TripDescriptor | None = ...,
        vehicle: global___VehicleDescriptor | None = ...,
        stop_time_update: collections.abc.Iterable[global___TripUpdate.StopTimeUpdate] | None = ...,
        timestamp: builtins.int | None = ...,
        delay: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["delay", b"delay", "timestamp", b"timestamp", "trip", b"trip", "vehicle", b"vehicle"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["delay", b"delay", "stop_time_update", b"stop_time_update", "timestamp", b"timestamp", "trip", b"trip", "vehicle", b"vehicle"]) -> None: ...

global___TripUpdate = TripUpdate

@typing_extensions.final
class VehiclePosition(google.protobuf.message.Message):
    """Realtime positioning information for a given vehicle."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _VehicleStopStatus:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _VehicleStopStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[VehiclePosition._VehicleStopStatus.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        INCOMING_AT: VehiclePosition._VehicleStopStatus.ValueType  # 0
        """The vehicle is just about to arrive at the stop (on a stop
        display, the vehicle symbol typically flashes).
        """
        STOPPED_AT: VehiclePosition._VehicleStopStatus.ValueType  # 1
        """The vehicle is standing at the stop."""
        IN_TRANSIT_TO: VehiclePosition._VehicleStopStatus.ValueType  # 2
        """The vehicle has departed and is in transit to the next stop."""

    class VehicleStopStatus(_VehicleStopStatus, metaclass=_VehicleStopStatusEnumTypeWrapper): ...
    INCOMING_AT: VehiclePosition.VehicleStopStatus.ValueType  # 0
    """The vehicle is just about to arrive at the stop (on a stop
    display, the vehicle symbol typically flashes).
    """
    STOPPED_AT: VehiclePosition.VehicleStopStatus.ValueType  # 1
    """The vehicle is standing at the stop."""
    IN_TRANSIT_TO: VehiclePosition.VehicleStopStatus.ValueType  # 2
    """The vehicle has departed and is in transit to the next stop."""

    class _CongestionLevel:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _CongestionLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[VehiclePosition._CongestionLevel.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN_CONGESTION_LEVEL: VehiclePosition._CongestionLevel.ValueType  # 0
        RUNNING_SMOOTHLY: VehiclePosition._CongestionLevel.ValueType  # 1
        STOP_AND_GO: VehiclePosition._CongestionLevel.ValueType  # 2
        CONGESTION: VehiclePosition._CongestionLevel.ValueType  # 3
        SEVERE_CONGESTION: VehiclePosition._CongestionLevel.ValueType  # 4
        """People leaving their cars."""

    class CongestionLevel(_CongestionLevel, metaclass=_CongestionLevelEnumTypeWrapper):
        """Congestion level that is affecting this vehicle."""

    UNKNOWN_CONGESTION_LEVEL: VehiclePosition.CongestionLevel.ValueType  # 0
    RUNNING_SMOOTHLY: VehiclePosition.CongestionLevel.ValueType  # 1
    STOP_AND_GO: VehiclePosition.CongestionLevel.ValueType  # 2
    CONGESTION: VehiclePosition.CongestionLevel.ValueType  # 3
    SEVERE_CONGESTION: VehiclePosition.CongestionLevel.ValueType  # 4
    """People leaving their cars."""

    class _OccupancyStatus:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _OccupancyStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[VehiclePosition._OccupancyStatus.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        EMPTY: VehiclePosition._OccupancyStatus.ValueType  # 0
        """The vehicle is considered empty by most measures, and has few or no
        passengers onboard, but is still accepting passengers.
        """
        MANY_SEATS_AVAILABLE: VehiclePosition._OccupancyStatus.ValueType  # 1
        """The vehicle has a relatively large percentage of seats available.
        What percentage of free seats out of the total seats available is to be
        considered large enough to fall into this category is determined at the
        discretion of the producer.
        """
        FEW_SEATS_AVAILABLE: VehiclePosition._OccupancyStatus.ValueType  # 2
        """The vehicle has a relatively small percentage of seats available.
        What percentage of free seats out of the total seats available is to be
        considered small enough to fall into this category is determined at the
        discretion of the feed producer.
        """
        STANDING_ROOM_ONLY: VehiclePosition._OccupancyStatus.ValueType  # 3
        """The vehicle can currently accommodate only standing passengers."""
        CRUSHED_STANDING_ROOM_ONLY: VehiclePosition._OccupancyStatus.ValueType  # 4
        """The vehicle can currently accommodate only standing passengers
        and has limited space for them.
        """
        FULL: VehiclePosition._OccupancyStatus.ValueType  # 5
        """The vehicle is considered full by most measures, but may still be
        allowing passengers to board.
        """
        NOT_ACCEPTING_PASSENGERS: VehiclePosition._OccupancyStatus.ValueType  # 6
        """The vehicle is not accepting additional passengers."""

    class OccupancyStatus(_OccupancyStatus, metaclass=_OccupancyStatusEnumTypeWrapper):
        """The degree of passenger occupancy of the vehicle. This field is still
        experimental, and subject to change. It may be formally adopted in the
        future.
        """

    EMPTY: VehiclePosition.OccupancyStatus.ValueType  # 0
    """The vehicle is considered empty by most measures, and has few or no
    passengers onboard, but is still accepting passengers.
    """
    MANY_SEATS_AVAILABLE: VehiclePosition.OccupancyStatus.ValueType  # 1
    """The vehicle has a relatively large percentage of seats available.
    What percentage of free seats out of the total seats available is to be
    considered large enough to fall into this category is determined at the
    discretion of the producer.
    """
    FEW_SEATS_AVAILABLE: VehiclePosition.OccupancyStatus.ValueType  # 2
    """The vehicle has a relatively small percentage of seats available.
    What percentage of free seats out of the total seats available is to be
    considered small enough to fall into this category is determined at the
    discretion of the feed producer.
    """
    STANDING_ROOM_ONLY: VehiclePosition.OccupancyStatus.ValueType  # 3
    """The vehicle can currently accommodate only standing passengers."""
    CRUSHED_STANDING_ROOM_ONLY: VehiclePosition.OccupancyStatus.ValueType  # 4
    """The vehicle can currently accommodate only standing passengers
    and has limited space for them.
    """
    FULL: VehiclePosition.OccupancyStatus.ValueType  # 5
    """The vehicle is considered full by most measures, but may still be
    allowing passengers to board.
    """
    NOT_ACCEPTING_PASSENGERS: VehiclePosition.OccupancyStatus.ValueType  # 6
    """The vehicle is not accepting additional passengers."""

    TRIP_FIELD_NUMBER: builtins.int
    VEHICLE_FIELD_NUMBER: builtins.int
    POSITION_FIELD_NUMBER: builtins.int
    CURRENT_STOP_SEQUENCE_FIELD_NUMBER: builtins.int
    STOP_ID_FIELD_NUMBER: builtins.int
    CURRENT_STATUS_FIELD_NUMBER: builtins.int
    TIMESTAMP_FIELD_NUMBER: builtins.int
    CONGESTION_LEVEL_FIELD_NUMBER: builtins.int
    OCCUPANCY_STATUS_FIELD_NUMBER: builtins.int
    @property
    def trip(self) -> global___TripDescriptor:
        """The Trip that this vehicle is serving.
        Can be empty or partial if the vehicle can not be identified with a given
        trip instance.
        """
    @property
    def vehicle(self) -> global___VehicleDescriptor:
        """Additional information on the vehicle that is serving this trip."""
    @property
    def position(self) -> global___Position:
        """Current position of this vehicle."""
    current_stop_sequence: builtins.int
    """The stop sequence index of the current stop. The meaning of
    current_stop_sequence (i.e., the stop that it refers to) is determined by
    current_status.
    If current_status is missing IN_TRANSIT_TO is assumed.
    """
    stop_id: builtins.str
    """Identifies the current stop. The value must be the same as in stops.txt in
    the corresponding GTFS feed.
    """
    current_status: global___VehiclePosition.VehicleStopStatus.ValueType
    """The exact status of the vehicle with respect to the current stop.
    Ignored if current_stop_sequence is missing.
    """
    timestamp: builtins.int
    """Moment at which the vehicle's position was measured. In POSIX time
    (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
    """
    congestion_level: global___VehiclePosition.CongestionLevel.ValueType
    occupancy_status: global___VehiclePosition.OccupancyStatus.ValueType
    def __init__(
        self,
        *,
        trip: global___TripDescriptor | None = ...,
        vehicle: global___VehicleDescriptor | None = ...,
        position: global___Position | None = ...,
        current_stop_sequence: builtins.int | None = ...,
        stop_id: builtins.str | None = ...,
        current_status: global___VehiclePosition.VehicleStopStatus.ValueType | None = ...,
        timestamp: builtins.int | None = ...,
        congestion_level: global___VehiclePosition.CongestionLevel.ValueType | None = ...,
        occupancy_status: global___VehiclePosition.OccupancyStatus.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["congestion_level", b"congestion_level", "current_status", b"current_status", "current_stop_sequence", b"current_stop_sequence", "occupancy_status", b"occupancy_status", "position", b"position", "stop_id", b"stop_id", "timestamp", b"timestamp", "trip", b"trip", "vehicle", b"vehicle"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["congestion_level", b"congestion_level", "current_status", b"current_status", "current_stop_sequence", b"current_stop_sequence", "occupancy_status", b"occupancy_status", "position", b"position", "stop_id", b"stop_id", "timestamp", b"timestamp", "trip", b"trip", "vehicle", b"vehicle"]) -> None: ...

global___VehiclePosition = VehiclePosition

@typing_extensions.final
class Alert(google.protobuf.message.Message):
    """An alert, indicating some sort of incident in the public transit network."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Cause:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _CauseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Alert._Cause.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN_CAUSE: Alert._Cause.ValueType  # 1
        OTHER_CAUSE: Alert._Cause.ValueType  # 2
        """Not machine-representable."""
        TECHNICAL_PROBLEM: Alert._Cause.ValueType  # 3
        STRIKE: Alert._Cause.ValueType  # 4
        """Public transit agency employees stopped working."""
        DEMONSTRATION: Alert._Cause.ValueType  # 5
        """People are blocking the streets."""
        ACCIDENT: Alert._Cause.ValueType  # 6
        HOLIDAY: Alert._Cause.ValueType  # 7
        WEATHER: Alert._Cause.ValueType  # 8
        MAINTENANCE: Alert._Cause.ValueType  # 9
        CONSTRUCTION: Alert._Cause.ValueType  # 10
        POLICE_ACTIVITY: Alert._Cause.ValueType  # 11
        MEDICAL_EMERGENCY: Alert._Cause.ValueType  # 12

    class Cause(_Cause, metaclass=_CauseEnumTypeWrapper):
        """Cause of this alert."""

    UNKNOWN_CAUSE: Alert.Cause.ValueType  # 1
    OTHER_CAUSE: Alert.Cause.ValueType  # 2
    """Not machine-representable."""
    TECHNICAL_PROBLEM: Alert.Cause.ValueType  # 3
    STRIKE: Alert.Cause.ValueType  # 4
    """Public transit agency employees stopped working."""
    DEMONSTRATION: Alert.Cause.ValueType  # 5
    """People are blocking the streets."""
    ACCIDENT: Alert.Cause.ValueType  # 6
    HOLIDAY: Alert.Cause.ValueType  # 7
    WEATHER: Alert.Cause.ValueType  # 8
    MAINTENANCE: Alert.Cause.ValueType  # 9
    CONSTRUCTION: Alert.Cause.ValueType  # 10
    POLICE_ACTIVITY: Alert.Cause.ValueType  # 11
    MEDICAL_EMERGENCY: Alert.Cause.ValueType  # 12

    class _Effect:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _EffectEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Alert._Effect.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        NO_SERVICE: Alert._Effect.ValueType  # 1
        REDUCED_SERVICE: Alert._Effect.ValueType  # 2
        SIGNIFICANT_DELAYS: Alert._Effect.ValueType  # 3
        """We don't care about INsignificant delays: they are hard to detect, have
        little impact on the user, and would clutter the results as they are too
        frequent.
        """
        DETOUR: Alert._Effect.ValueType  # 4
        ADDITIONAL_SERVICE: Alert._Effect.ValueType  # 5
        MODIFIED_SERVICE: Alert._Effect.ValueType  # 6
        OTHER_EFFECT: Alert._Effect.ValueType  # 7
        UNKNOWN_EFFECT: Alert._Effect.ValueType  # 8
        STOP_MOVED: Alert._Effect.ValueType  # 9

    class Effect(_Effect, metaclass=_EffectEnumTypeWrapper):
        """What is the effect of this problem on the affected entity."""

    NO_SERVICE: Alert.Effect.ValueType  # 1
    REDUCED_SERVICE: Alert.Effect.ValueType  # 2
    SIGNIFICANT_DELAYS: Alert.Effect.ValueType  # 3
    """We don't care about INsignificant delays: they are hard to detect, have
    little impact on the user, and would clutter the results as they are too
    frequent.
    """
    DETOUR: Alert.Effect.ValueType  # 4
    ADDITIONAL_SERVICE: Alert.Effect.ValueType  # 5
    MODIFIED_SERVICE: Alert.Effect.ValueType  # 6
    OTHER_EFFECT: Alert.Effect.ValueType  # 7
    UNKNOWN_EFFECT: Alert.Effect.ValueType  # 8
    STOP_MOVED: Alert.Effect.ValueType  # 9

    ACTIVE_PERIOD_FIELD_NUMBER: builtins.int
    INFORMED_ENTITY_FIELD_NUMBER: builtins.int
    CAUSE_FIELD_NUMBER: builtins.int
    EFFECT_FIELD_NUMBER: builtins.int
    URL_FIELD_NUMBER: builtins.int
    HEADER_TEXT_FIELD_NUMBER: builtins.int
    DESCRIPTION_TEXT_FIELD_NUMBER: builtins.int
    @property
    def active_period(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TimeRange]:
        """Time when the alert should be shown to the user. If missing, the
        alert will be shown as long as it appears in the feed.
        If multiple ranges are given, the alert will be shown during all of them.
        """
    @property
    def informed_entity(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EntitySelector]:
        """Entities whose users we should notify of this alert."""
    cause: global___Alert.Cause.ValueType
    effect: global___Alert.Effect.ValueType
    @property
    def url(self) -> global___TranslatedString:
        """The URL which provides additional information about the alert."""
    @property
    def header_text(self) -> global___TranslatedString:
        """Alert header. Contains a short summary of the alert text as plain-text."""
    @property
    def description_text(self) -> global___TranslatedString:
        """Full description for the alert as plain-text. The information in the
        description should add to the information of the header.
        """
    def __init__(
        self,
        *,
        active_period: collections.abc.Iterable[global___TimeRange] | None = ...,
        informed_entity: collections.abc.Iterable[global___EntitySelector] | None = ...,
        cause: global___Alert.Cause.ValueType | None = ...,
        effect: global___Alert.Effect.ValueType | None = ...,
        url: global___TranslatedString | None = ...,
        header_text: global___TranslatedString | None = ...,
        description_text: global___TranslatedString | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cause", b"cause", "description_text", b"description_text", "effect", b"effect", "header_text", b"header_text", "url", b"url"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["active_period", b"active_period", "cause", b"cause", "description_text", b"description_text", "effect", b"effect", "header_text", b"header_text", "informed_entity", b"informed_entity", "url", b"url"]) -> None: ...

global___Alert = Alert

@typing_extensions.final
class TimeRange(google.protobuf.message.Message):
    """
    Low level data structures used above.

    A time interval. The interval is considered active at time 't' if 't' is
    greater than or equal to the start time and less than the end time.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    start: builtins.int
    """Start time, in POSIX time (i.e., number of seconds since January 1st 1970
    00:00:00 UTC).
    If missing, the interval starts at minus infinity.
    """
    end: builtins.int
    """End time, in POSIX time (i.e., number of seconds since January 1st 1970
    00:00:00 UTC).
    If missing, the interval ends at plus infinity.
    """
    def __init__(
        self,
        *,
        start: builtins.int | None = ...,
        end: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end", b"end", "start", b"start"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end", b"end", "start", b"start"]) -> None: ...

global___TimeRange = TimeRange

@typing_extensions.final
class Position(google.protobuf.message.Message):
    """A position."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LATITUDE_FIELD_NUMBER: builtins.int
    LONGITUDE_FIELD_NUMBER: builtins.int
    BEARING_FIELD_NUMBER: builtins.int
    ODOMETER_FIELD_NUMBER: builtins.int
    SPEED_FIELD_NUMBER: builtins.int
    latitude: builtins.float
    """Degrees North, in the WGS-84 coordinate system."""
    longitude: builtins.float
    """Degrees East, in the WGS-84 coordinate system."""
    bearing: builtins.float
    """Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
    This can be the compass bearing, or the direction towards the next stop
    or intermediate location.
    This should not be direction deduced from the sequence of previous
    positions, which can be computed from previous data.
    """
    odometer: builtins.float
    """Odometer value, in meters."""
    speed: builtins.float
    """Momentary speed measured by the vehicle, in meters per second."""
    def __init__(
        self,
        *,
        latitude: builtins.float | None = ...,
        longitude: builtins.float | None = ...,
        bearing: builtins.float | None = ...,
        odometer: builtins.float | None = ...,
        speed: builtins.float | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bearing", b"bearing", "latitude", b"latitude", "longitude", b"longitude", "odometer", b"odometer", "speed", b"speed"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bearing", b"bearing", "latitude", b"latitude", "longitude", b"longitude", "odometer", b"odometer", "speed", b"speed"]) -> None: ...

global___Position = Position

@typing_extensions.final
class TripDescriptor(google.protobuf.message.Message):
    """A descriptor that identifies an instance of a GTFS trip, or all instances of
    a trip along a route.
    - To specify a single trip instance, the trip_id (and if necessary,
      start_time) is set. If route_id is also set, then it should be same as one
      that the given trip corresponds to.
    - To specify all the trips along a given route, only the route_id should be
      set. Note that if the trip_id is not known, then stop sequence ids in
      TripUpdate are not sufficient, and stop_ids must be provided as well. In
      addition, absolute arrival/departure times must be provided.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ScheduleRelationship:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ScheduleRelationshipEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[TripDescriptor._ScheduleRelationship.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SCHEDULED: TripDescriptor._ScheduleRelationship.ValueType  # 0
        """Trip that is running in accordance with its GTFS schedule, or is close
        enough to the scheduled trip to be associated with it.
        """
        ADDED: TripDescriptor._ScheduleRelationship.ValueType  # 1
        """An extra trip that was added in addition to a running schedule, for
        example, to replace a broken vehicle or to respond to sudden passenger
        load.
        """
        UNSCHEDULED: TripDescriptor._ScheduleRelationship.ValueType  # 2
        """A trip that is running with no schedule associated to it, for example, if
        there is no schedule at all.
        """
        CANCELED: TripDescriptor._ScheduleRelationship.ValueType  # 3
        """A trip that existed in the schedule but was removed."""

    class ScheduleRelationship(_ScheduleRelationship, metaclass=_ScheduleRelationshipEnumTypeWrapper):
        """The relation between this trip and the static schedule. If a trip is done
        in accordance with temporary schedule, not reflected in GTFS, then it
        shouldn't be marked as SCHEDULED, but likely as ADDED.
        """

    SCHEDULED: TripDescriptor.ScheduleRelationship.ValueType  # 0
    """Trip that is running in accordance with its GTFS schedule, or is close
    enough to the scheduled trip to be associated with it.
    """
    ADDED: TripDescriptor.ScheduleRelationship.ValueType  # 1
    """An extra trip that was added in addition to a running schedule, for
    example, to replace a broken vehicle or to respond to sudden passenger
    load.
    """
    UNSCHEDULED: TripDescriptor.ScheduleRelationship.ValueType  # 2
    """A trip that is running with no schedule associated to it, for example, if
    there is no schedule at all.
    """
    CANCELED: TripDescriptor.ScheduleRelationship.ValueType  # 3
    """A trip that existed in the schedule but was removed."""

    TRIP_ID_FIELD_NUMBER: builtins.int
    ROUTE_ID_FIELD_NUMBER: builtins.int
    DIRECTION_ID_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    START_DATE_FIELD_NUMBER: builtins.int
    SCHEDULE_RELATIONSHIP_FIELD_NUMBER: builtins.int
    trip_id: builtins.str
    """The trip_id from the GTFS feed that this selector refers to.
    For non frequency-based trips, this field is enough to uniquely identify
    the trip. For frequency-based trip, start_time and start_date might also be
    necessary.
    """
    route_id: builtins.str
    """The route_id from the GTFS that this selector refers to."""
    direction_id: builtins.int
    """The direction_id from the GTFS feed trips.txt file, indicating the
    direction of travel for trips this selector refers to. This field is
    still experimental, and subject to change. It may be formally adopted in
    the future.
    """
    start_time: builtins.str
    """The initially scheduled start time of this trip instance.
    When the trip_id corresponds to a non-frequency-based trip, this field
    should either be omitted or be equal to the value in the GTFS feed. When
    the trip_id corresponds to a frequency-based trip, the start_time must be
    specified for trip updates and vehicle positions. If the trip corresponds
    to exact_times=1 GTFS record, then start_time must be some multiple
    (including zero) of headway_secs later than frequencies.txt start_time for
    the corresponding time period. If the trip corresponds to exact_times=0,
    then its start_time may be arbitrary, and is initially expected to be the
    first departure of the trip. Once established, the start_time of this
    frequency-based trip should be considered immutable, even if the first
    departure time changes -- that time change may instead be reflected in a
    StopTimeUpdate.
    Format and semantics of the field is same as that of
    GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
    """
    start_date: builtins.str
    """The scheduled start date of this trip instance.
    Must be provided to disambiguate trips that are so late as to collide with
    a scheduled trip on a next day. For example, for a train that departs 8:00
    and 20:00 every day, and is 12 hours late, there would be two distinct
    trips on the same time.
    This field can be provided but is not mandatory for schedules in which such
    collisions are impossible - for example, a service running on hourly
    schedule where a vehicle that is one hour late is not considered to be
    related to schedule anymore.
    In YYYYMMDD format.
    """
    schedule_relationship: global___TripDescriptor.ScheduleRelationship.ValueType
    def __init__(
        self,
        *,
        trip_id: builtins.str | None = ...,
        route_id: builtins.str | None = ...,
        direction_id: builtins.int | None = ...,
        start_time: builtins.str | None = ...,
        start_date: builtins.str | None = ...,
        schedule_relationship: global___TripDescriptor.ScheduleRelationship.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["direction_id", b"direction_id", "route_id", b"route_id", "schedule_relationship", b"schedule_relationship", "start_date", b"start_date", "start_time", b"start_time", "trip_id", b"trip_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["direction_id", b"direction_id", "route_id", b"route_id", "schedule_relationship", b"schedule_relationship", "start_date", b"start_date", "start_time", b"start_time", "trip_id", b"trip_id"]) -> None: ...

global___TripDescriptor = TripDescriptor

@typing_extensions.final
class VehicleDescriptor(google.protobuf.message.Message):
    """Identification information for the vehicle performing the trip."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    LICENSE_PLATE_FIELD_NUMBER: builtins.int
    id: builtins.str
    """Internal system identification of the vehicle. Should be unique per
    vehicle, and can be used for tracking the vehicle as it proceeds through
    the system.
    """
    label: builtins.str
    """User visible label, i.e., something that must be shown to the passenger to
    help identify the correct vehicle.
    """
    license_plate: builtins.str
    """The license plate of the vehicle."""
    def __init__(
        self,
        *,
        id: builtins.str | None = ...,
        label: builtins.str | None = ...,
        license_plate: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["id", b"id", "label", b"label", "license_plate", b"license_plate"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id", "label", b"label", "license_plate", b"license_plate"]) -> None: ...

global___VehicleDescriptor = VehicleDescriptor

@typing_extensions.final
class EntitySelector(google.protobuf.message.Message):
    """A selector for an entity in a GTFS feed."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AGENCY_ID_FIELD_NUMBER: builtins.int
    ROUTE_ID_FIELD_NUMBER: builtins.int
    ROUTE_TYPE_FIELD_NUMBER: builtins.int
    TRIP_FIELD_NUMBER: builtins.int
    STOP_ID_FIELD_NUMBER: builtins.int
    agency_id: builtins.str
    """The values of the fields should correspond to the appropriate fields in the
    GTFS feed.
    At least one specifier must be given. If several are given, then the
    matching has to apply to all the given specifiers.
    """
    route_id: builtins.str
    route_type: builtins.int
    """corresponds to route_type in GTFS."""
    @property
    def trip(self) -> global___TripDescriptor: ...
    stop_id: builtins.str
    def __init__(
        self,
        *,
        agency_id: builtins.str | None = ...,
        route_id: builtins.str | None = ...,
        route_type: builtins.int | None = ...,
        trip: global___TripDescriptor | None = ...,
        stop_id: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["agency_id", b"agency_id", "route_id", b"route_id", "route_type", b"route_type", "stop_id", b"stop_id", "trip", b"trip"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["agency_id", b"agency_id", "route_id", b"route_id", "route_type", b"route_type", "stop_id", b"stop_id", "trip", b"trip"]) -> None: ...

global___EntitySelector = EntitySelector

@typing_extensions.final
class TranslatedString(google.protobuf.message.Message):
    """An internationalized message containing per-language versions of a snippet of
    text or a URL.
    One of the strings from a message will be picked up. The resolution proceeds
    as follows:
    1. If the UI language matches the language code of a translation,
       the first matching translation is picked.
    2. If a default UI language (e.g., English) matches the language code of a
       translation, the first matching translation is picked.
    3. If some translation has an unspecified language code, that translation is
       picked.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class Translation(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TEXT_FIELD_NUMBER: builtins.int
        LANGUAGE_FIELD_NUMBER: builtins.int
        text: builtins.str
        """A UTF-8 string containing the message."""
        language: builtins.str
        """BCP-47 language code. Can be omitted if the language is unknown or if
        no i18n is done at all for the feed. At most one translation is
        allowed to have an unspecified language tag.
        """
        def __init__(
            self,
            *,
            text: builtins.str | None = ...,
            language: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["language", b"language", "text", b"text"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["language", b"language", "text", b"text"]) -> None: ...

    TRANSLATION_FIELD_NUMBER: builtins.int
    @property
    def translation(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TranslatedString.Translation]:
        """At least one translation must be provided."""
    def __init__(
        self,
        *,
        translation: collections.abc.Iterable[global___TranslatedString.Translation] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["translation", b"translation"]) -> None: ...

global___TranslatedString = TranslatedString
